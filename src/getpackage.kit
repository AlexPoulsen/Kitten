include "limits.h";
include "unistd.h";
include "sys/types.h";
include "sys/stat.h";
include "jansson.h";
include "errno.h";
import init;
import stringbuilder;
import processpackage;


function main() {
    var root: StringBuilder = StringBuilder.newFromString("/usr/local/lib/kit");
    updatePackageJSONs(root.makeCopy());
    // pullPackage("xs_rounding", root.makeCopy());
    updatePackage("xs_rounding", root.makeCopy());
}


function updatePackageJSONs(root: StringBuilder) {
    var cwd: Ptr[Char] = malloc(${PATH_MAX: Int} * sizeof(Char));
    if (getcwd(cwd, ${PATH_MAX: Int} * sizeof(Char)) != null) {
        chdir(root.returnWithString("/_kitten_json_dir"));
        system("git pull");
        chdir(cwd);
    } else {
        perror("getcwd() error");
    }
}


function copyFile(from: CString, to: CString) {
    printf("%s -> %s\n", from, to);
    var fromFile: Ptr[__sFILE] = fopen(from, "r");
    var toFile: Ptr[__sFILE] = fopen(to, "w");
    if fromFile == null {
        perror("Error opening file");
        printf("%s\n", fromFile);
    } else if toFile == null {
        perror("Error opening file");
        printf("%s\n", toFile);
    } else {
        var line: CArray[Char, 2048];
        while fgets(line, sizeof(CArray[Char, 2048]), fromFile) != null {
            fprintf(toFile, "%s", line);
        }
        fclose(fromFile);
        fclose(toFile);
    }
}


function pullPackage(pkg: CString, root: StringBuilder) {
    var packagedir: StringBuilder = root.makeCopy().appendString("/kitten/_kitten_packages");
    var jsondir: StringBuilder = root.makeCopy().appendString("/kitten/_kitten_json_dir/packages");
    var filename: StringBuilder = jsondir.makeCopy().appendString("/").appendString(pkg).appendString(".json");
    printf("%s\n", filename.toString());
    var fp: Ptr[FILE] = fopen(filename.toString(), "r");
    var lSize: Int64;
    var buffer: Ptr[Char];
    var jsonData: Ptr[json_t];
    var jsonError: json_error_t;
    if fp == null {
        perror("Error opening file");
        printf("%s\n", filename.toString());
    } else {
        printf("opened %s\n", filename.toString());
        fseek(fp, 0, SEEK_END);
        lSize = ftell(fp);
        rewind(fp);
        buffer = calloc(1, lSize+1);
        if 1 != fread(buffer, lSize, 1 , fp) {
            fclose(fp);
            free(buffer);
            fputs("entire read fails\n", stderr);
        } else {
            printf("reading succeeded\n%s\n", buffer);
            jsonData = json_loads(buffer, 0, &jsonError);
            fclose(fp);
            free(buffer);
            if jsonData.type == JSON_OBJECT {
                printf("JSON is object\n");
                var link: Ptr[json_t] = json_object_get(jsonData, "github link");
                var id: Ptr[json_t] = json_object_get(jsonData, "id");
                var linkIsString: Bool = false;
                var idIsString: Bool = false;
                if link.type == JSON_STRING {
                    linkIsString = true;
                } else {
                    printf("Error: no GitHub link");
                }
                if id.type == JSON_STRING {
                    idIsString = true;
                } else {
                    printf("Error: no `id` string");
                }
                if idIsString && linkIsString {
                    const linkString: CString = json_string_value(link);
                    const idString: CString = json_string_value(id);
                    printf("%s\n", json_string_value(link));
                    chdir(packagedir.toString());
                    var dirCmd: StringBuilder = StringBuilder.newFromString("rm -rf ");
                    dirCmd.appendString(packagedir.toString());
                    dirCmd.appendString("/");
                    dirCmd.appendString(idString);
                    const mkdirSuccess = mkdir(dirCmd.toString(), 0o777);
                    var gitCmd: StringBuilder = StringBuilder.newFromString("git clone ");
                    // gitCmd.appendString(packagedir.toString());
                    // gitCmd.appendString("/");
                    gitCmd.appendString(linkString);
                    if (strstr(dirCmd.toString(), "&") != null) && (strstr(dirCmd.toString(), ";") != null) {
                        // prevents a package that adds a second command or deletes a different directory from being easily entered
                        if mkdirSuccess != 0 {
                            // printf("%s\n", dirCmd.toString());
                            system(dirCmd.toString());
                        } else {
                            // printf("%s\n", dirCmd.toString());
                            system(dirCmd.toString());
                        }
                    }
                    // printf("%s\n", gitCmd.toString());
                    system(gitCmd.toString());
                    var gitRepoName: Ptr[Char] = strrchr(linkString, c'/');
                    if gitRepoName != null {
                        printf("%s\n", gitRepoName);
                        rename(packagedir.makeCopy().appendString("/").appendString(gitRepoName).returnWithString("/"), packagedir.makeCopy().appendString("/").appendString(pkg).returnWithString("/"));
                    }
                    copyFile(filename.toString(), packagedir.makeCopy().appendString("/").appendString(pkg).appendString("/").appendString(pkg).returnWithString(".json"));
                    rename(packagedir.makeCopy().appendString("/").appendString(pkg).appendString("/").appendString(pkg).returnWithString(".json"), packagedir.makeCopy().appendString("/").appendString(pkg).appendString("/").returnWithString("kitten.json"));
                }
            } else {
                printf("Error: malformed kitten.json");
            }
            json_decref(jsonData);
        }
    }
}


function updatePackage(pkg: CString, root: StringBuilder) {
    chdir(root.makeCopy().appendString("/kitten/_kitten_packages").appendString("/").returnWithString(pkg));
    system("git pull");
    processpackage.process(pkg, root);
}
